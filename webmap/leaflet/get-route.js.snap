/**
 * Custom Routing System
 * Two-step routing: City‚ÜíGate (public OSRM) + Gate‚ÜíGrave (local OSRM)
 * With live GPS tracking every 3 seconds
 */

/** Cemetery main entrance coordinate
* this will snap the route to the nearest
* point of this coordinate and switch from 
* public OSRM to local OSRM **/
var CEMETERY_GATE = L.latLng(10.248107820799307, 123.797607547609545);

// Navigation state
var navigationState = {
    isActive: false,
    watchId: null,
    currentRoute: null,
    userMarker: null,
    routeLines: [],
    destinationMarker: null,
    // Dynamic routing properties
    destination: null, // Store final destination
    lastUserPosition: null,
    routeDeviation: false,
    rerouteThreshold: 15, // meters - distance before considering reroute (reduced from 50m to 15m)
    progressCheckInterval: null,
    currentRouteProgress: 0,
    totalRouteCoordinates: [],
    lastRouteUpdate: null, // Timestamp of last route update to prevent excessive updates
    // Route snapping properties
    snappedPosition: null, // Current snapped position on route
    lastRawPosition: null, // Last raw GPS position before snapping
    // Animation properties
    animationInProgress: false,
    animationFrameId: null,
    animationStartTime: null,
    animationStartPosition: null,
    animationEndPosition: null,
    animationDuration: 500, // milliseconds
    // Simulation properties
    isSimulating: false,
    simulationInterval: null,
    simulationIndex: 0,
    simulationCoordinates: [],
    simulationSpeed: 1000 // milliseconds between moves (1 seconds)
};

/**
 * Main navigation function - called in get-direction button
 */
function navigateToGrave(graveLat, graveLng) {
    console.log('üöÄ Starting two-step navigation to grave:', [graveLat, graveLng]);
    
    if (!navigator.geolocation) {
        alert('GPS not supported by your browser');
        return;
    }

    // Clear any existing navigation
    stopNavigation();

    // Get user's current location
    navigator.geolocation.getCurrentPosition(
        function(position) {
            var userLat = position.coords.latitude;
            var userLng = position.coords.longitude;
            
            console.log('üìç User location:', [userLat, userLng]);
            
            // Store destination for dynamic routing
            navigationState.destination = { lat: graveLat, lng: graveLng };
            navigationState.lastUserPosition = { lat: userLat, lng: userLng };
            
            // Start two-step routing
            createTwoStepRoute(userLat, userLng, graveLat, graveLng);
        },
        function(error) {
            alert('Could not get your location. Please enable GPS and try again.');
            console.error('Geolocation error:', error);
        },
        {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 30000
        }
    );
}

/**
 * Create the two-step route: City‚ÜíGate + Gate‚ÜíGrave
 */
function createTwoStepRoute(userLat, userLng, graveLat, graveLng) {
    console.log('üõ£Ô∏è Creating two-step route...');
    
    var gateLat = CEMETERY_GATE.lat;
    var gateLng = CEMETERY_GATE.lng;
    
    // Step 1: Route from user to cemetery gate (public OSRM)
    getRoute(
        userLat, userLng, gateLat, gateLng,
        'https://router.project-osrm.org/route/v1/driving', // Public OSRM for city travel
        '#FF6B6B', // Red color for city route
        function(step1Route) {
            console.log('‚úÖ Step 1 (City‚ÜíGate) route found');
            
            // Ensure route starts exactly at user's position
            var userStartRoute = extendRouteFromUser(step1Route, userLat, userLng);
            
            // Step 2: Route from gate to grave (local OSRM foot profile)
            getRoute(
                gateLat, gateLng, graveLat, graveLng,

                // For local testing
                // 'http://localhost:5000/route/v1/foot',

                // Production URL for local OSRM
                'https://finisterreosm-production.up.railway.app/route/v1/foot',
                '#4ECDC4', // Teal color for cemetery route - change color here
                function(step2Route) {
                    console.log('‚úÖ Step 2 (Gate‚ÜíGrave) route found');
                    
                    // Add final segment from footpath to exact grave location
                    var finalRoute = extendRouteToGrave(step2Route, graveLat, graveLng);
                    
                    // Display both routes and start tracking
                    displayRoutes([userStartRoute, finalRoute], userLat, userLng, graveLat, graveLng);
                    
                    // Store total route coordinates for progress tracking
                    storeRouteForProgress([userStartRoute, finalRoute]);
                    
                    startLiveTracking();
                }
            );
        }
    );
}

/**
 * Get route from OSRM service
 */
function getRoute(startLat, startLng, endLat, endLng, serviceUrl, color, callback) {
    var url = serviceUrl + '/' + startLng + ',' + startLat + ';' + endLng + ',' + endLat + 
              '?overview=full&geometries=geojson';
    
    fetch(url)
        .then(function(response) {
            if (!response.ok) throw new Error('Network response was not ok');
            return response.json();
        })
        .then(function(data) {
            if (data.routes && data.routes.length > 0) {
                var route = data.routes[0];
                var coordinates = route.geometry.coordinates.map(function(coord) {
                    return [coord[1], coord[0]]; // Convert [lng, lat] to [lat, lng]
                });
                
                // Ensure the first point is exactly the user's location (snap starting point)
                coordinates[0] = [startLat, startLng];
                
                callback({
                    coordinates: coordinates,
                    distance: route.distance,
                    duration: route.duration,
                    color: color
                });
            } else {
                throw new Error('No route found');
            }
        })
        .catch(function(error) {
            console.error('Routing error:', error);
            alert('Could not find route. Please try again.');
        });}


/**
 * Extend route to snap directly to the grave location
 * Adds a final segment from the footpath endpoint to the exact grave coordinates
 */
function extendRouteToGrave(footpathRoute, graveLat, graveLng) {
    var coordinates = footpathRoute.coordinates.slice(); // Copy the footpath coordinates
    var lastPoint = coordinates[coordinates.length - 1];
    var lastLat = lastPoint[0];
    var lastLng = lastPoint[1];
    
    // Calculate distance between footpath end and grave
    var distance = calculateDistanceBetweenPoints(lastLat, lastLng, graveLat, graveLng);
    
    // Only add direct connection if grave is more than 2 meters from footpath end
    if (distance > 2) {
        console.log('üìç Adding direct connection to grave (' + distance.toFixed(1) + 'm from footpath)');
        coordinates.push([graveLat, graveLng]); // Add direct line to grave
        
        // Update the route distance and duration
        return {
            coordinates: coordinates,
            distance: footpathRoute.distance + distance,
            duration: footpathRoute.duration + (distance / 1.4), // Walking speed 1.4 m/s
            color: footpathRoute.color
        };
    }
    
    return footpathRoute; // Return original if grave is already close to footpath
}

/**
 * Calculate distance between two points in meters using Haversine formula
 */
function calculateDistanceBetweenPoints(lat1, lng1, lat2, lng2) {
    var R = 6371000; // Earth's radius in meters
    var dLat = (lat2 - lat1) * Math.PI / 180;
    var dLng = (lng2 - lng1) * Math.PI / 180;
    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLng / 2) * Math.sin(dLng / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

/**
 * Store route coordinates for progress tracking
 */
function storeRouteForProgress(routes) {
    navigationState.totalRouteCoordinates = [];
    routes.forEach(function(route) {
        navigationState.totalRouteCoordinates = navigationState.totalRouteCoordinates.concat(route.coordinates);
    });
    navigationState.currentRouteProgress = 0;
    console.log('üìä Stored', navigationState.totalRouteCoordinates.length, 'route points for progress tracking');
}

/**
 * Find the closest point on the route to the user's position and snap to it
 * Returns an object with the snapped position and whether rerouting is needed
 */
function snapToRoute(userLat, userLng) {
    if (!navigationState.destination || navigationState.totalRouteCoordinates.length === 0) {
        return {
            snapped: false,
            needsReroute: false,
            position: { lat: userLat, lng: userLng },
            closestIndex: 0,
            closestDistance: Infinity
        };
    }
    
    // Find closest point on current route and update progress
    var closestDistance = Infinity;
    var closestIndex = 0;
    var closestPoint = null;
    
    // Look ahead from current progress (with a small buffer to allow for backtracking)
    var searchStartIndex = Math.max(0, navigationState.currentRouteProgress - 10);
    
    for (var i = searchStartIndex; i < navigationState.totalRouteCoordinates.length; i++) {
        var routePoint = navigationState.totalRouteCoordinates[i];
        var distance = calculateDistanceBetweenPoints(userLat, userLng, routePoint[0], routePoint[1]);
        
        if (distance < closestDistance) {
            closestDistance = distance;
            closestIndex = i;
            closestPoint = routePoint;
        }
    }
    
    // Update progress (only move forward unless significant backtracking detected)
    if (closestIndex > navigationState.currentRouteProgress || 
        (navigationState.currentRouteProgress - closestIndex) > 10) { // Allow backtracking if significant
        navigationState.currentRouteProgress = closestIndex;
        console.log('üìà Route progress updated:', Math.round((closestIndex / navigationState.totalRouteCoordinates.length) * 100) + '%');
    }
    
    // Dynamic reroute threshold based on context
    var dynamicThreshold = navigationState.rerouteThreshold;
    
    // Be more tolerant near the destination
    var progress = navigationState.currentRouteProgress / navigationState.totalRouteCoordinates.length;
    if (progress > 0.9) {
        dynamicThreshold = 20; // 20m near destination
    } else if (progress > 0.7) {
        dynamicThreshold = 30; // 30m in cemetery
    }
    
    // Determine if rerouting is needed
    var needsReroute = closestDistance > dynamicThreshold;
    
    if (needsReroute) {
        console.log('üîÑ User is', Math.round(closestDistance), 'm from route (threshold:', dynamicThreshold + 'm) - triggering reroute');
        showRerouteNotification();
    }
    
    return {
        snapped: true,
        needsReroute: needsReroute,
        position: { lat: closestPoint[0], lng: closestPoint[1] },
        closestIndex: closestIndex,
        closestDistance: closestDistance,
        rawPosition: { lat: userLat, lng: userLng }
    };
}

/**
 * Check if user has deviated from route and needs rerouting
 */
function checkForReroute(userLat, userLng) {
    var snapResult = snapToRoute(userLat, userLng);
    navigationState.snappedPosition = snapResult.position;
    return snapResult.needsReroute;
}

/**
 * Show a brief notification when rerouting
 */
function showRerouteNotification() {
    var notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #FF6B6B;
        color: white;
        padding: 12px 20px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(255,107,107,0.3);
        animation: slideInOut 3s ease-in-out;
    `;
    notification.innerHTML = '<i class="fas fa-route" style="margin-right: 8px;"></i>Recalculating route...';
    
    // Add animation keyframes
    if (!document.getElementById('reroute-animation')) {
        var style = document.createElement('style');
        style.id = 'reroute-animation';
        style.textContent = `
            @keyframes slideInOut {
                0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                20%, 80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            }
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translateY(-10px); }
                20%, 80% { opacity: 1; transform: translateY(0); }
                100% { opacity: 0; transform: translateY(-10px); }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(notification);
    
    setTimeout(function() {
        document.body.removeChild(notification);
    }, 3000);
}

/**
 * Trigger rerouting from current position to destination with improved logic
 */
function triggerReroute(userLat, userLng) {
    if (!navigationState.destination || navigationState.routeDeviation) {
        return; // Already rerouting or no destination
    }
    
    console.log('üîÑ Rerouting from current position to destination...');
    navigationState.routeDeviation = true;
    
    // Temporarily update user marker to show rerouting state
    if (navigationState.userMarker) {
        var originalIcon = navigationState.userMarker.getIcon();
        var rerouteIcon = L.divIcon({
            html: '<div class="user-marker rerouting"><i class="fas fa-sync-alt fa-spin"></i></div>',
            className: 'custom-user-marker',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        navigationState.userMarker.setIcon(rerouteIcon);
        
        // Restore original icon after rerouting
        setTimeout(function() {
            if (navigationState.userMarker) {
                navigationState.userMarker.setIcon(originalIcon);
            }
        }, 2000);
    }
    
    // Use the raw GPS position for rerouting, not the snapped position
    // This ensures we route from the user's actual location, not from the old route
    var routeFromLat = userLat;
    var routeFromLng = userLng;
    
    // Use dynamic route update
    updateRouteFromCurrentPosition(routeFromLat, routeFromLng);
    
    // Reset deviation flag after a delay
    setTimeout(function() {
        navigationState.routeDeviation = false;
    }, 3000);
}

/**
 * Calculate bearing between two points
 */
function calculateBearing(lat1, lng1, lat2, lng2) {
    var dLng = (lng2 - lng1) * Math.PI / 180;
    var lat1Rad = lat1 * Math.PI / 180;
    var lat2Rad = lat2 * Math.PI / 180;
    
    var y = Math.sin(dLng) * Math.cos(lat2Rad);
    var x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);
    
    var bearing = Math.atan2(y, x) * 180 / Math.PI;
    return (bearing + 360) % 360;
}

/**
 * Get turn direction based on bearing change
 */
function getTurnDirection(currentBearing, nextBearing) {
    var diff = (nextBearing - currentBearing + 360) % 360;
    
    if (diff >= 315 || diff <= 45) {
        return { direction: 'straight', icon: 'fas fa-arrow-up' };
    } else if (diff > 45 && diff <= 135) {
        return { direction: 'right', icon: 'fas fa-arrow-right' };
    } else if (diff > 135 && diff <= 225) {
        return { direction: 'u-turn', icon: 'fas fa-undo' };
    } else {
        return { direction: 'left', icon: 'fas fa-arrow-left' };
    }
}

/**
 * Get current direction based on user progress along route with turn-by-turn navigation
 */
function getCurrentDirectionFromProgress() {
    if (!navigationState.isActive || navigationState.totalRouteCoordinates.length === 0) {
        return {
            icon: 'fas fa-map-marker-alt',
            instruction: 'Start navigation',
            distance: '',
            progress: 0
        };
    }
    
    var progress = navigationState.currentRouteProgress;
    var totalPoints = navigationState.totalRouteCoordinates.length;
    var progressPercent = Math.round((progress / totalPoints) * 100);
    
    // Calculate remaining distance to destination
    var remainingDistance = 0;
    if (progress < totalPoints - 1) {
        for (var i = progress; i < totalPoints - 1; i++) {
            var point1 = navigationState.totalRouteCoordinates[i];
            var point2 = navigationState.totalRouteCoordinates[i + 1];
            remainingDistance += calculateDistanceBetweenPoints(point1[0], point1[1], point2[0], point2[1]);
        }
    }
    
    // Get next turn information
    var instruction = 'Continue straight';
    var icon = 'fas fa-arrow-up';
    var nextTurnDistance = 0;
    
    // Look ahead for significant turns
    var lookAheadPoints = Math.min(10, totalPoints - progress - 1);
    if (lookAheadPoints >= 3) {
        var currentPoint = navigationState.totalRouteCoordinates[progress];
        var midPoint = navigationState.totalRouteCoordinates[progress + Math.floor(lookAheadPoints / 2)];
        var futurePoint = navigationState.totalRouteCoordinates[progress + lookAheadPoints];
        
        var currentBearing = calculateBearing(currentPoint[0], currentPoint[1], midPoint[0], midPoint[1]);
        var futureBearing = calculateBearing(midPoint[0], midPoint[1], futurePoint[0], futurePoint[1]);
        
        var turn = getTurnDirection(currentBearing, futureBearing);
        
        // Calculate distance to turn
        for (var i = progress; i < progress + lookAheadPoints && i < totalPoints - 1; i++) {
            var p1 = navigationState.totalRouteCoordinates[i];
            var p2 = navigationState.totalRouteCoordinates[i + 1];
            nextTurnDistance += calculateDistanceBetweenPoints(p1[0], p1[1], p2[0], p2[1]);
        }
        
        if (turn.direction !== 'straight') {
            icon = turn.icon;
            if (nextTurnDistance < 50) {
                instruction = `Turn ${turn.direction} in ${Math.round(nextTurnDistance)}m`;
            } else if (nextTurnDistance < 200) {
                instruction = `Prepare to turn ${turn.direction}`;
            }
        }
    }
    
    // Context-based instructions
    if (progressPercent < 10) {
        instruction = 'Head toward cemetery gate';
        icon = 'fas fa-map-marker-alt';
    } else if (progressPercent < 30) {
        instruction = 'Continue to cemetery entrance';
        icon = 'fas fa-arrow-up';
    } else if (progressPercent > 90) {
        instruction = 'Arrive at destination';
        icon = 'fas fa-flag-checkered';
    } else if (remainingDistance < 30) {
        instruction = 'Approaching destination';
        icon = 'fas fa-map-marker-alt';
    }
    
    return {
        icon: icon,
        instruction: instruction,
        distance: formatDistance(remainingDistance),
        progress: progressPercent,
        nextTurn: nextTurnDistance > 0 ? formatDistance(nextTurnDistance) : null
    };
}

/**
 * Update directions panel with current progress and turn-by-turn navigation
 */
function updateDirectionsPanel() {
    var directionsPanel = document.getElementById('directions-panel');
    if (!directionsPanel) return;
    
    var currentDirection = getCurrentDirectionFromProgress();
    
    directionsPanel.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <div style="background: #007AFF; border-radius: 50%; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; margin-right: 15px; box-shadow: 0 2px 8px rgba(0,122,255,0.3);">
                <i class="${currentDirection.icon}" style="color: white; font-size: 20px;"></i>
            </div>
            <div style="flex: 1;">
                <div style="font-weight: bold; color: #333; font-size: 17px; line-height: 1.3;">
                    ${currentDirection.instruction}
                </div>
                <div style="color: #666; font-size: 14px; margin-top: 4px; display: flex; align-items: center; gap: 8px;">
                    <span style="display: flex; align-items: center;">
                        <i class="fas fa-location-arrow" style="margin-right: 4px; font-size: 12px; color: #007AFF;"></i>
                        ${currentDirection.distance}
                    </span>
                    ${currentDirection.nextTurn ? `
                    <span style="display: flex; align-items: center; background: #f8f9fa; padding: 2px 6px; border-radius: 4px;">
                        <i class="fas fa-route" style="margin-right: 4px; font-size: 11px; color: #6c757d;"></i>
                        Next: ${currentDirection.nextTurn}
                    </span>
                    ` : ''}
                </div>
                ${currentDirection.progress ? `
                <div style="margin-top: 8px;">
                    <div style="background: #f0f0f0; border-radius: 10px; height: 8px; position: relative; overflow: hidden;">
                        <div style="background: linear-gradient(90deg, #007AFF, #00C7BE); border-radius: 10px; height: 8px; width: ${currentDirection.progress}%; transition: width 0.5s ease; box-shadow: 0 1px 3px rgba(0,122,255,0.2);"></div>
                    </div>
                    <div style="font-size: 12px; color: #999; margin-top: 4px; display: flex; justify-content: space-between; align-items: center;">
                        <span>${currentDirection.progress}% complete</span>
                        <span style="font-weight: 500; color: #007AFF;">
                            <i class="fas fa-clock" style="margin-right: 3px; font-size: 10px;"></i>
                            ETA: ${getEstimatedTimeArrival()}
                        </span>
                    </div>
                </div>
                ` : ''}
            </div>
        </div>
    `;
}

/**
 * Calculate estimated time of arrival based on remaining distance and average walking speed
 */
function getEstimatedTimeArrival() {
    if (!navigationState.isActive || navigationState.totalRouteCoordinates.length === 0) {
        return '--:--';
    }
    
    var progress = navigationState.currentRouteProgress;
    var totalPoints = navigationState.totalRouteCoordinates.length;
    
    // Calculate remaining distance
    var remainingDistance = 0;
    if (progress < totalPoints - 1) {
        for (var i = progress; i < totalPoints - 1; i++) {
            var point1 = navigationState.totalRouteCoordinates[i];
            var point2 = navigationState.totalRouteCoordinates[i + 1];
            remainingDistance += calculateDistanceBetweenPoints(point1[0], point1[1], point2[0], point2[1]);
        }
    }
    
    // Average walking speed: 1.4 m/s (5 km/h)
    var walkingSpeed = 1.4;
    var eta = remainingDistance / walkingSpeed; // seconds
    
    if (eta < 60) {
        return Math.round(eta) + 's';
    } else {
        var minutes = Math.floor(eta / 60);
        var seconds = Math.round(eta % 60);
        return minutes + 'm ' + (seconds > 0 ? seconds + 's' : '');
    }
}

/**
 * Create custom user location icon with FontAwesome
 */
function createUserIcon() {
    return L.divIcon({
        html: '<div class="user-marker"><i class="fas fa-user"></i></div><i class="fas fa-caret-up direction-arrow"></i>',
        className: 'custom-user-marker',
        iconSize: [30, 30],
        iconAnchor: [15, 15]
    });
}

/**
 * Update user marker direction based on movement
 */
function updateUserMarkerDirection(prevLat, prevLng, newLat, newLng) {
    if (!navigationState.userMarker) return;
    
    // Calculate bearing between points
    var bearing = calculateBearing(prevLat, prevLng, newLat, newLng);
    
    // Only update if movement is significant
    var distance = calculateDistanceBetweenPoints(prevLat, prevLng, newLat, newLng);
    if (distance < 2) return; // Don't update direction for tiny movements
    
    // Get the arrow element
    var markerElement = navigationState.userMarker.getElement();
    if (!markerElement) return;
    
    var arrowElement = markerElement.querySelector('.direction-arrow');
    if (!arrowElement) return;
    
    // Update arrow rotation
    arrowElement.style.transform = `translateX(-50%) rotate(${bearing}deg)`;
}

/**
 * Create custom destination icon with FontAwesome
 */
function createDestinationIcon() {
    return L.divIcon({
        html: '<div class="destination-marker"><i class="fas fa-map-marker-alt"></i></div>',
        className: 'custom-destination-marker',
        iconSize: [30, 30],
        iconAnchor: [15, 30]
    });
}

/**
 * Display the routes on the map (initial setup)
 */
function displayRoutes(routes, userLat, userLng, graveLat, graveLng) {
    // Clear existing routes
    navigationState.routeLines.forEach(function(line) {
        map.removeLayer(line);
    });
    navigationState.routeLines = [];
    
    // Store route coordinates for progress tracking
    storeRouteForProgress(routes);
    
    // Add route lines with improved styling
    routes.forEach(function(route) {
        var routeLine = L.polyline(route.coordinates, {
            color: route.color,
            weight: 6,
            opacity: 0.8,
            lineCap: 'round',
            lineJoin: 'round',
            dashArray: null
        }).addTo(map);
        
        // Add subtle animation effect to highlight the route
        routeLine.setStyle({ opacity: 0.4 });
        setTimeout(function() {
            if (routeLine && map.hasLayer(routeLine)) {
                routeLine.setStyle({ opacity: 0.8 });
            }
        }, 300);
        
        navigationState.routeLines.push(routeLine);
    });
    
    // Add user marker (styled with FontAwesome icon)
    navigationState.userMarker = L.marker([userLat, userLng], {
        icon: createUserIcon(),
        zIndexOffset: 1000 // Ensure user marker is on top
    }).addTo(map);
    
    // Add destination marker (styled map pin)
    navigationState.destinationMarker = L.marker([graveLat, graveLng], {
        icon: createDestinationIcon()
    }).addTo(map);
    
    // Fit map to show full route
    var group = L.featureGroup([
        navigationState.userMarker,
        navigationState.destinationMarker
    ].concat(navigationState.routeLines));
    map.fitBounds(group.getBounds().pad(0.1));
    
    // Calculate total stats
    var totalDistance = routes.reduce(function(sum, route) { return sum + route.distance; }, 0);
    var totalDuration = routes.reduce(function(sum, route) { return sum + route.duration; }, 0);
    
    showNavigationPanel(totalDistance, totalDuration);
    navigationState.isActive = true;
    
    // Initialize snapped position
    navigationState.snappedPosition = { lat: userLat, lng: userLng };
}

/**
 * Extend route to snap directly to the user's current location
 * Adds an initial segment from the exact user coordinates to the first point on the route
 */
function extendRouteFromUser(route, userLat, userLng) {
    var coordinates = route.coordinates.slice(); // Copy the route coordinates
    var firstPoint = coordinates[0];
    var firstLat = firstPoint[0];
    var firstLng = firstPoint[1];
    
    // Calculate distance between user and first point on route
    var distance = calculateDistanceBetweenPoints(userLat, userLng, firstLat, firstLng);
    
    // Only add direct connection if user is more than 2 meters from route start
    if (distance > 2) {
        console.log('üìç Adding direct connection from user (' + distance.toFixed(1) + 'm from route start)');
        coordinates.unshift([userLat, userLng]); // Add direct line from user at the beginning
        
        // Update the route distance and duration
        return {
            coordinates: coordinates,
            distance: route.distance + distance,
            duration: route.duration + (distance / 1.4), // Walking speed 1.4 m/s
            color: route.color
        };
    }
    
    return route; // Return original if user is already close to route start
}

/**
 * Update route from current user position dynamically
 */
function updateRouteFromCurrentPosition(userLat, userLng) {
    if (!navigationState.destination || !navigationState.isActive) {
        return;
    }
    
    // Prevent excessive updates - only update if enough time has passed
    var now = Date.now();
    if (navigationState.lastRouteUpdate && (now - navigationState.lastRouteUpdate) < 5000) {
        console.log('‚è±Ô∏è Skipping route update - too frequent (last update:', ((now - navigationState.lastRouteUpdate) / 1000).toFixed(1), 's ago)');
        return;
    }
    
    console.log('üîÑ Updating route from current position:', [userLat, userLng]);
    navigationState.lastRouteUpdate = now;
    
    // Show route update indicator
    showRouteUpdateIndicator();
    
    // Create new route from current position to destination
    var destLat = navigationState.destination.lat;
    var destLng = navigationState.destination.lng;
    var gateLat = CEMETERY_GATE.lat;
    var gateLng = CEMETERY_GATE.lng;
    
    // Determine if user is closer to gate or destination
    var distanceToGate = calculateDistanceBetweenPoints(userLat, userLng, gateLat, gateLng);
    var distanceToDestination = calculateDistanceBetweenPoints(userLat, userLng, destLat, destLng);
    
    // If user is very close to destination (within 100m), route directly
    if (distanceToDestination < 100) {
        console.log('üìç User close to destination - routing directly');
        // Direct route to destination
        var directRoute = {
            coordinates: [[userLat, userLng], [destLat, destLng]],
            distance: distanceToDestination,
            duration: distanceToDestination / 1.4, // Walking speed
            color: '#4ECDC4'
        };
        
        displayUpdatedRoute([directRoute], userLat, userLng);
    }
    // If user is closer to destination than to gate, skip city routing
    else if (distanceToDestination < distanceToGate) {
        console.log('üö∂ User inside cemetery - routing via local paths');
        // Route from current position directly to grave via local OSRM
        getRoute(
            userLat, userLng, destLat, destLng,
            'https://finisterreosm-production.up.railway.app/route/v1/foot',
            '#4ECDC4',
            function(cemeteryRoute) {
                // Ensure route starts exactly at user's position
                var userStartRoute = extendRouteFromUser(cemeteryRoute, userLat, userLng);
                // Ensure route ends exactly at grave location
                var finalRoute = extendRouteToGrave(userStartRoute, destLat, destLng);
                displayUpdatedRoute([finalRoute], userLat, userLng);
            }
        );
    }
    // User is still in the city, need two-step routing
    else {
        console.log('üöó User in city - using two-step routing');
        // Step 1: Route from user to cemetery gate
        getRoute(
            userLat, userLng, gateLat, gateLng,
            'https://router.project-osrm.org/route/v1/driving',
            '#FF6B6B',
            function(step1Route) {
                // Ensure route starts exactly at user's position
                var userStartRoute = extendRouteFromUser(step1Route, userLat, userLng);
                
                // Step 2: Route from gate to grave
                getRoute(
                    gateLat, gateLng, destLat, destLng,
                    'https://finisterreosm-production.up.railway.app/route/v1/foot',
                    '#4ECDC4',
                    function(step2Route) {
                        var finalRoute = extendRouteToGrave(step2Route, destLat, destLng);
                        displayUpdatedRoute([userStartRoute, finalRoute], userLat, userLng);
                    }
                );
            }
        );
    }
}

/**
 * Show a brief indicator when route is being updated
 */
function showRouteUpdateIndicator() {
    var indicator = document.createElement('div');
    indicator.id = 'route-update-indicator';
    indicator.style.cssText = `
        position: fixed;
        top: 80px;
        left: 20px;
        background: #4ECDC4;
        color: white;
        padding: 8px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(78,205,196,0.3);
        animation: fadeInOut 2s ease-in-out;
    `;
    indicator.innerHTML = '<i class="fas fa-route" style="margin-right: 6px;"></i>Updating route...';
    
    // Remove existing indicator if present
    var existing = document.getElementById('route-update-indicator');
    if (existing) {
        existing.remove();
    }
    
    document.body.appendChild(indicator);
    
    setTimeout(function() {
        if (indicator && indicator.parentNode) {
            indicator.parentNode.removeChild(indicator);
        }
    }, 2000);
}

/**
 * Display updated route without changing markers or panels
 */
function displayUpdatedRoute(routes, userLat, userLng) {
    // Clear any existing route lines first with fade-out effect
    navigationState.routeLines.forEach(function(line) {
        // Fade out old route
        line.setStyle({ opacity: 0.2 });
        setTimeout(function() {
            if (map.hasLayer(line)) {
                map.removeLayer(line);
            }
        }, 300);
    });
    navigationState.routeLines = [];
    
    // Add new route lines with animation effect
    routes.forEach(function(route, index) {
        var routeLine = L.polyline(route.coordinates, {
            color: route.color,
            weight: 6,
            opacity: 0,  // Start invisible for animation
            lineCap: 'round',
            lineJoin: 'round'
        }).addTo(map);
        
        // Animate route appearance with sequential timing
        setTimeout(function() {
            if (routeLine && map.hasLayer(routeLine)) {
                // Animate to full opacity
                routeLine.setStyle({ opacity: 0.8 });
            }
        }, 300 + (100 * index)); // Stagger the animations
        
        navigationState.routeLines.push(routeLine);
    });
    
    // Don't update user marker position directly - it's handled by the snapping system
    // Instead, update the snapped position
    navigationState.snappedPosition = { lat: userLat, lng: userLng };
    
    // Store updated route coordinates for progress tracking
    storeRouteForProgress(routes);
    
    // Update navigation panel with new stats
    var totalDistance = routes.reduce(function(sum, route) { return sum + route.distance; }, 0);
    var totalDuration = routes.reduce(function(sum, route) { return sum + route.duration; }, 0);
    
    updateNavigationPanelStats(totalDistance, totalDuration);
    
    console.log('‚úÖ Route updated dynamically - new route has', routes.length, 'segments');
}

/**
 * Update navigation panel stats without recreating the whole panel
 */
function updateNavigationPanelStats(totalDistance, totalDuration) {
    var panel = document.getElementById('nav-panel');
    if (!panel) return;
    
    var distanceKm = (totalDistance / 1000).toFixed(1);
    var durationMin = Math.round(totalDuration / 60);
    
    // Find and update distance and duration elements
    var distanceElement = panel.querySelector('[data-stat="distance"]');
    var durationElement = panel.querySelector('[data-stat="duration"]');
    
    if (distanceElement) {
        distanceElement.textContent = distanceKm + ' km';
    }
    if (durationElement) {
        durationElement.textContent = durationMin + ' min';
    }
}

/**
 * Animate user marker movement smoothly between positions
 */
function animateUserMarker(startLat, startLng, endLat, endLng) {
    if (!navigationState.userMarker || navigationState.animationInProgress) return;
    
    // Cancel any existing animation
    if (navigationState.animationFrameId) {
        cancelAnimationFrame(navigationState.animationFrameId);
    }
    
    navigationState.animationInProgress = true;
    navigationState.animationStartTime = Date.now();
    navigationState.animationStartPosition = { lat: startLat, lng: startLng };
    navigationState.animationEndPosition = { lat: endLat, lng: endLng };
    
    function animate() {
        var now = Date.now();
        var elapsed = now - navigationState.animationStartTime;
        var progress = Math.min(elapsed / navigationState.animationDuration, 1);
        
        // Ease function (cubic ease-out)
        var easedProgress = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate position
        var lat = navigationState.animationStartPosition.lat + 
                 (navigationState.animationEndPosition.lat - navigationState.animationStartPosition.lat) * easedProgress;
        var lng = navigationState.animationStartPosition.lng + 
                 (navigationState.animationEndPosition.lng - navigationState.animationStartPosition.lng) * easedProgress;
        
        // Update marker position
        navigationState.userMarker.setLatLng([lat, lng]);
        
        // Continue animation if not complete
        if (progress < 1) {
            navigationState.animationFrameId = requestAnimationFrame(animate);
        } else {
            navigationState.animationInProgress = false;
            navigationState.animationFrameId = null;
        }
    }
    
    // Start animation
    navigationState.animationFrameId = requestAnimationFrame(animate);
}

/**
 * Start live GPS tracking (updates every 3 seconds) with dynamic routing and route snapping
 */
function startLiveTracking() {
    if (!navigator.geolocation) return;
    
    console.log('üîÑ Starting live GPS tracking with route snapping and dynamic routing (every 3 seconds)');
    
    navigationState.watchId = navigator.geolocation.watchPosition(
        function(position) {
            if (navigationState.isActive && navigationState.userMarker) {
                var newLat = position.coords.latitude;
                var newLng = position.coords.longitude;
                
                // Store raw GPS position
                navigationState.lastRawPosition = { lat: newLat, lng: newLng };
                console.log('üì° Raw GPS position:', [newLat, newLng]);
                
                // Snap to route and check for rerouting
                var snapResult = snapToRoute(newLat, newLng);
                var snappedLat = snapResult.position.lat;
                var snappedLng = snapResult.position.lng;
                
                // Store snapped position
                navigationState.snappedPosition = { lat: snappedLat, lng: snappedLng };
                
                // Animate movement to snapped position
                if (navigationState.userMarker.getLatLng()) {
                    var currentPos = navigationState.userMarker.getLatLng();
                    animateUserMarker(currentPos.lat, currentPos.lng, snappedLat, snappedLng);
                } else {
                    // First position, no animation needed
                    navigationState.userMarker.setLatLng([snappedLat, snappedLng]);
                }
                
                console.log('üìç Snapped position:', [snappedLat, snappedLng], 
                          '(Distance from raw:', Math.round(snapResult.closestDistance), 'm)');
                
                // Check if user has moved significantly from last position
                if (navigationState.lastUserPosition) {
                    var movedDistance = calculateDistanceBetweenPoints(
                        newLat, newLng,
                        navigationState.lastUserPosition.lat,
                        navigationState.lastUserPosition.lng
                    );
                    
                    // Only process if user has moved more than 5 meters
                    if (movedDistance > 5) {
                        // Check if rerouting is needed
                        if (snapResult.needsReroute) {
                            triggerReroute(newLat, newLng);
                        } else {
                            // Update directions panel with current progress
                            updateDirectionsPanel();
                        }
                        
                        // Update last position
                        navigationState.lastUserPosition = { lat: newLat, lng: newLng };
                    }
                } else {
                    // First position update
                    navigationState.lastUserPosition = { lat: newLat, lng: newLng };
                }
            }
        },
        function(error) {
            console.warn('Live tracking error:', error);
        },
        {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 3000 // 3 second intervals
        }
    );
}

/**
 * Start simulating user movement along the route for testing
 */
function startRouteSimulation() {
    if (!navigationState.isActive || navigationState.routeLines.length === 0) {
        console.warn('‚ö†Ô∏è Cannot start simulation: no active route');
        return;
    }
    
    // Collect all coordinates from all route segments
    navigationState.simulationCoordinates = [];
    navigationState.routeLines.forEach(function(routeLine) {
        var coords = routeLine.getLatLngs();
        navigationState.simulationCoordinates = navigationState.simulationCoordinates.concat(coords);
    });
    
    // Start from beginning
    navigationState.simulationIndex = 0;
    navigationState.isSimulating = true;
    
    console.log('üé¨ Starting route simulation with', navigationState.simulationCoordinates.length, 'waypoints');
    console.log('üèÉ Simulating movement every', navigationState.simulationSpeed / 1000, 'seconds');
    
    // Start the simulation interval
    navigationState.simulationInterval = setInterval(function() {
        if (navigationState.simulationIndex < navigationState.simulationCoordinates.length) {
            var currentPoint = navigationState.simulationCoordinates[navigationState.simulationIndex];
            
            // Update user marker position
            if (navigationState.userMarker) {
                navigationState.userMarker.setLatLng(currentPoint);
                
                // Update progress tracking for simulation
                if (navigationState.totalRouteCoordinates.length > 0) {
                    checkForReroute(currentPoint.lat, currentPoint.lng);
                    updateDirectionsPanel();
                }
                
                console.log('üéØ Simulated position:', [currentPoint.lat, currentPoint.lng], 
                           '(Step', navigationState.simulationIndex + 1, 'of', navigationState.simulationCoordinates.length + ')');
            }
            
            navigationState.simulationIndex++;
        } else {
            // Reached the end of the route
            console.log('üèÅ Simulation completed - reached destination!');
            stopRouteSimulation();
        }
    }, navigationState.simulationSpeed);
    
    // Update the navigation panel to show simulation status
    updateNavigationPanelForSimulation(true);
}

/**
 * Stop route simulation
 */
function stopRouteSimulation() {
    if (navigationState.simulationInterval) {
        clearInterval(navigationState.simulationInterval);
        navigationState.simulationInterval = null;
    }
    
    navigationState.isSimulating = false;
    navigationState.simulationIndex = 0;
    navigationState.simulationCoordinates = [];
    
    console.log('‚èπÔ∏è Route simulation stopped');
    
    // Update the navigation panel to remove simulation status
    updateNavigationPanelForSimulation(false);
}

/**
 * Update navigation panel to show simulation controls
 */
function updateNavigationPanelForSimulation(isSimulating) {
    var panel = document.getElementById('nav-panel');
    if (!panel) return;
    
    var existingSimControls = document.getElementById('sim-controls');
    if (existingSimControls) {
        existingSimControls.remove();
    }
    
    if (isSimulating) {
        var simControls = document.createElement('div');
        simControls.id = 'sim-controls';
        simControls.style.cssText = `
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        `;
        
        simControls.innerHTML = `
            <div style="display: flex; align-items: center;">
                <i class="fas fa-play-circle" style="color: #4CAF50; margin-right: 6px; font-size: 14px;"></i>
                <span style="font-size: 12px; color: #4CAF50; font-weight: bold;">SIMULATION ACTIVE</span>
            </div>
            <button onclick="stopRouteSimulation()" style="background: #FFA726; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 11px;">
                <i class="fas fa-stop" style="margin-right: 4px;"></i>Stop
            </button>
        `;
        
        panel.appendChild(simControls);
    }
}

/**
 * Show navigation info panel with Font Awesome icons and directions
 */
function showNavigationPanel(totalDistance, totalDuration) {
    var distanceKm = (totalDistance / 1000).toFixed(1);
    var durationMin = Math.round(totalDuration / 60);
    
    // Remove existing panels
    var existingPanel = document.getElementById('nav-panel');
    var existingDirections = document.getElementById('directions-panel');
    if (existingPanel) existingPanel.remove();
    if (existingDirections) existingDirections.remove();
    
    // Create main navigation panel
    var panel = document.createElement('div');
    panel.id = 'nav-panel';
    panel.style.cssText = `
        position: fixed;
        top: 20px;
        left: 20px;
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        font-family: Arial, sans-serif;
        min-width: 280px;
        border: 1px solid #e0e0e0;
    `;
    
    panel.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div style="display: flex; align-items: center;">
                <i class="fas fa-route" style="color: #007AFF; margin-right: 8px; font-size: 16px;"></i>
                <strong style="color: #333;">Navigation Active</strong>
            </div>
            <button onclick="stopNavigation()" style="background: #FF3B30; color: white; border: none; border-radius: 50%; padding: 8px; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">
                <i class="fas fa-times" style="font-size: 12px;"></i>
            </button>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div style="display: flex; align-items: center;">
                <i class="fas fa-road" style="color: #666; margin-right: 6px; font-size: 14px;"></i>
                <span style="font-size: 14px; color: #666;" data-stat="distance">${distanceKm} km</span>
            </div>
            <div style="display: flex; align-items: center;">
                <i class="fas fa-clock" style="color: #666; margin-right: 6px; font-size: 14px;"></i>
                <span style="font-size: 14px; color: #666;" data-stat="duration">${durationMin} min</span>
            </div>
        </div>
        <div style="display: flex; align-items: center; justify-content: space-between;">
            <div style="display: flex; align-items: center; font-size: 12px; color: #999;">
                <i class="fas fa-location-dot" style="margin-right: 6px; color: #4CAF50;"></i>
                <span>Live tracking enabled</span>
            </div>





            <button onclick="startRouteSimulation()" style="background: #2196F3; color: white; border: none; border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 11px;">
                <i class="fas fa-play" style="margin-right: 4px;"></i>Test Route
            </button>
        </div>
    `;
    
    // Create directions panel below main panel
    var directionsPanel = document.createElement('div');
    directionsPanel.id = 'directions-panel';
    directionsPanel.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        font-family: Arial, sans-serif;
        min-width: 280px;
        border: 1px solid #e0e0e0;
    `;
    
    // Get current direction
    var currentDirection = getCurrentDirectionFromProgress();
    
    directionsPanel.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <div style="background: #007AFF; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                <i class="${currentDirection.icon}" style="color: white; font-size: 18px;"></i>
            </div>
            <div>
                <div style="font-weight: bold; color: #333; font-size: 16px;">${currentDirection.instruction}</div>
                <div style="color: #666; font-size: 14px; margin-top: 2px;">
                    <i class="fas fa-location-arrow" style="margin-right: 4px; font-size: 12px;"></i>
                    ${currentDirection.distance}
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(panel);
    document.body.appendChild(directionsPanel);
}

/**
 * Format distance for display (meters or kilometers)
 */
function formatDistance(meters) {
    if (meters < 1000) {
        return Math.round(meters) + 'm';
    } else {
        return (meters / 1000).toFixed(1) + 'km';
    }
}

/**
 * Stop navigation and clean up everything
 */
function stopNavigation() {
    console.log('üõë Stopping navigation...');
    
    // Stop route simulation if running
    if (navigationState.isSimulating) {
        stopRouteSimulation();
    }
    
    // Stop GPS tracking
    if (navigationState.watchId) {
        navigator.geolocation.clearWatch(navigationState.watchId);
        navigationState.watchId = null;
    }
    
    // Remove route lines
    navigationState.routeLines.forEach(function(line) {
        map.removeLayer(line);
    });
    navigationState.routeLines = [];
    
    // Remove markers
    if (navigationState.userMarker) {
        map.removeLayer(navigationState.userMarker);
        navigationState.userMarker = null;
    }
    
    if (navigationState.destinationMarker) {
        map.removeLayer(navigationState.destinationMarker);
        navigationState.destinationMarker = null;
    }
    
    // Remove info panels
    var panel = document.getElementById('nav-panel');
    var directionsPanel = document.getElementById('directions-panel');
    if (panel) panel.remove();
    if (directionsPanel) directionsPanel.remove();
    
    // Reset state
    navigationState.isActive = false;
    navigationState.currentRoute = null;
    navigationState.destination = null;
    navigationState.lastUserPosition = null;
    navigationState.routeDeviation = false;
    navigationState.currentRouteProgress = 0;
    navigationState.totalRouteCoordinates = [];

    console.log('‚úÖ Navigation stopped and cleaned up');
}

// Make functions globally available
window.navigateToGrave = navigateToGrave;
window.stopNavigation = stopNavigation;
window.startRouteSimulation = startRouteSimulation;
window.stopRouteSimulation = stopRouteSimulation;

// Add custom marker styles to the page
(function addMarkerStyles() {
    var style = document.createElement('style');
    style.textContent = `
        /* Custom user location marker */
        .custom-user-marker .user-marker {
            background: #4CAF50;
            border: 3px solid #fff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
            transition: all 0.3s ease;
        }

        .custom-user-marker .user-marker i {
            color: white;
            font-size: 14px;
        }

        /* Rerouting state for user marker */
        .custom-user-marker .user-marker.rerouting {
            background: #FF6B6B;
            animation: pulse-reroute 1s infinite;
        }

        /* Custom destination marker */
        .custom-destination-marker .destination-marker {
            background: #f44336;
            border: 2px solid #fff;
            border-radius: 50% 50% 50% 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transform: rotate(-45deg);
        }

        .custom-destination-marker .destination-marker i {
            color: white;
            font-size: 16px;
            transform: rotate(45deg);
        }

        /* Pulse animation for user marker */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }

        /* Pulse animation for rerouting */
        @keyframes pulse-reroute {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.8);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(255, 107, 107, 0);
                transform: scale(1.1);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 107, 107, 0);
                transform: scale(1);
            }
        }

        /* Route animation */
        @keyframes routeFadeIn {
            from { opacity: 0; stroke-dashoffset: 1000; }
            to { opacity: 0.8; stroke-dashoffset: 0; }
        }

        /* Smooth transitions for marker movement */
        .custom-user-marker {
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
        }
        
        /* Direction arrow for user marker */
        .direction-arrow {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            color: #4CAF50;
            font-size: 16px;
            text-shadow: 0 0 3px rgba(255,255,255,0.8);
            transition: transform 0.3s ease;
        }
    `;
    document.head.appendChild(style);
})();

console.log('üó∫Ô∏è Clean Cemetery Navigation System loaded');
console.log('üìç Cemetery gate set to:', CEMETERY_GATE.lat, CEMETERY_GATE.lng);
console.log('üéØ Usage: navigateToGrave(lat, lng) or stopNavigation()');
console.log('üé¨ Testing: startRouteSimulation() to simulate movement along route');
